# Interprocess Communication
---
## Sockets
- A socket is an abstraction that allows to ignore the details of transport and network layers.
- Each socket has a "name" that is a pair of IP and port.
- Two types of sockets:
	- Connection oriented: Transmission Control Protocol (TCP)
	- Datagram oriented (Connectionless): User Datagram Protocol (UDP)
- In `C` we need the following libraries
	- `sys/socket.h` contains the functions  (`socket`, `bind`... ).
	- `netinet/in.h` contains:
		- Main structures (`sockaddr_in`)
		- Constants (`INADDR_ANY`, `INADDR_LOOPBACK`, `INADDR_BROADCAST`...)
		- Byte conversion (network always use big endian / IPs has 4B and ports 2B)
			- `htonl()` (host to network long): 4 host bytes to big endian
			- `htons()` (host to network short): 2 host bytes to big endian
			- `ntohl()` (network to host long): 4 big endian bytes to host
			- `ntohs()` (network to host short): 2 big endian bytes to host
---
## Socket usage
### 1 - Create a socket
```C
// PF_INET for IPv4
// SOCK_STREAM = TCP and SOCK_DGRAM = UDP 
// Returns -1 if error
int my_socket = socket(PF_INET, SOCK_STREAM, 0);
```
### 2 - Assign a name to a socket
```C
struct sockaddr_in local_addr; // Structure with "name" (IP and port)

// Socket in family = IPv4
local_addr.sin_family = AF_INET;
// Socket in address, source address = any address (32 bits in Big endian)
local_addr.sin_addr.s_addr = htonl(INADDR_ANY);
// Socket in port = port 7890 (16 bits in Big endian)
local_addr.sin_port = htons(7890);

// Actual assignation of the name
// Returns -1 if error
bind(my_socket, (struct sockaddr *)&local_addr, sizeof(local_addr));
```
### 3.1 - TCP Service
```C
// Turn created socket to passive mode (Create as my_socket in previous steps)
// SOMAXCONN = Queue for waiting connections as large as the SO allows.
listen(passive_socket, SOMAXCONN);

// Infinite service loop
while(1)
{
	// data_socket is used for message transmision with a single client.
	// Accept blocks the process until a client connects.
	data_socket = accept(passive_socket, 0, 0);
	
	// Service actions
	char buffer[200]; // For receiving bytes we need a buffer
	bytes_received = recv(data_socket, buffer, 200, 0);	// We receive the data
	send(data_socket, msg, strlen(msg), 0);	// We send some other data
	
	// We close the connection
	close(data_socket);
}
```

```C
// The client creates a socket for communication WITHOUT binding
int data_socket = socket(PF_INET, SOCK_STREAM, 0);

// Creates a structure with the server name
struct sockaddr_in server_addr;
server_addr.sin_family = AF_INET;
server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
server_addr.sin_port = htons(7890);

// Tries to connect to the server
connect(data_socket, (struct sockaddr *)&server_addr, sizeof(server_addr));
```
### 3.2 - UDP Service
```C
struct sockaddr_in client_addr;

// Infinite service loop
while(1)
{
	char buffer[50]; // For receiving bytes we need a buffer
	
	// data_socket is created as my_socket in previous steps
	// receives num bytes inside stored inside buffer
	// client_addr is automaticly created when the data is received
	num = recvfrom(
		data_socket, buffer, 50, 0,
		(struct sockaddr *)&client_addr, sizeof(client_addr)
	);
	
	// Sends data to the client that sended data previously
	sendto(
		data_socket, msg, strlen(msg), 0,
		(struct sockaddr *) &client_addr, length_addr
	);
}
```
---
## Other functions
- `atoi()`. Converts ASCII to Integer.
	```C
	short port = atoi("7890");
	```
- `inet_adddr()`. Returns an IP with the correct format from a string.
	```C
	address.sin_addr.s_addr = inet_addr("127.0.0.1");
	```
- `inet_aton()`. Similar to `inet_addr` but inserts the IP directly to the structure.
	```C
	#include <arpa/inet.h>
	if(inet_ntoa("127.0.0.1", & address.sin_addr) == 0) exit(EXIT_ERROR);
	```
- `inet_ntoa()`.  Symmetric to `inet_aton`.
	```C
	#include <arpa/inet.h>
	char *str_ip = inet_ntoa(client_address.sin_addr);
	```
- `gethostbyname()`. Performs a DNS query to resolve a name.
	```C
	#include <netdb.h>
	struct hostent *information;
	information = gethostbyname("www.google.com");
	if (information == NULL) exit(EXIT_ERROR);
	```
---
## Concurrent Server Techniques in C
- Multi-process
	- Uses `fork()` to create processes
	- Creates an independent copy of the parent process
	- Problems about data sharing between processes
- Multi-threaded
	- Uses threads
	- Shares everything but program counter (PC) and stack (local variables)
	- Concurrent access issues with the client_service function
- Input/Output Multiplexing
	- Uses `select()` function
	- Single thread that divides attention between several descriptors.
### Multiprocess programming
- **Uses the function `fork()`**
	```C
	if (fork() == 0) {
		// Child process
	} else {
		// Parent process
	}
	```
- **On-demand process creation**
	```C
	Create passive_socket
	Bind passive_socket
	while(1)
	{
		data_socket = accept(passive_socket) 
		if (fork() == 0) {
			// I am the child
			close(passive_socket)
			client_service(data_socket)
			exit()
			// Be aware of zombie processes
		} else {
			// I am the parent
			close(data_socket)
		}
	}
	```
- **Pre-creation of processes**
	```C
	Create passive_socket
	Bind passive_socket
	
	for(int i=0; i<N; i++) fork(); // Fork is time consuming. Faster than before
	
	while(1) // N + 1 processes will serve clients
	{
		data_socket = accept(sp) // Requires mutual exclusion for this line
		client_service(data_socket)
		close(data_socket)
	}
	```
### Multithreaded programming
```C
pthread_t tid_child; // Identifiers of each thread
pthread_attr_t attr; // Initialization

pthread_attr_init(&attr);
pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);

if ( pthread_create(&tid_child, &attr, function_child, NULL) ) exit(EXIT_ERROR)

```